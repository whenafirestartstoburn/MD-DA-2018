---
title: 'hw1'
author: 'dislosure fan'
datetime: "28th September, 2108 1:42"
output:
  html_document: default
  pdf_document: default
---

## Работа с данными

Для начала загрузим данные в data.df:


```{r}
data.df <- read.table('http://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat')
```

Получили следующий результат - http://prntscr.com/kz4p69 - значит все хорошо.

```{r}
if(!nrow(data.df)==5070 && !ncol(data.df)==27)
  print('You are doing something wrong')
```

Получим наименования столбцов:

```{r}
colnames(data.df)
```

Найдем значение из 5 строки 7 столбца:

```{r}
data.df[5,7]
```

2 строка целиком:

```{r}
data.df[2,]
```

Данная строка кода:

```{r}
names(data.df) <- c("year", "month", "day", seq(0,23))
colnames(data.df)
```

изменяет наименования колонок на "year", "month", "day" и числа от 0 до 23. Это можно проверить, выполнив функцию colnames.

Воспользуемся функциями head и tail для просмотра data.df:

```{r}
head(data.df)
tail(data.df)
```

"Что представляют собой последние 24 колонки?" Если действительно имелись в виду колонки, то, собственно, в последних 24 колонках содержатся данные об осадкаХ, поскольку первые 3 колонки содержат дату. А если имелись в виде последние 24 ряда, то это можно проверить так:

```{r}
tail(data.df, 24)
```

И узнать что с 08.11.80 по 30.11.80 осадков не было.

Добавим новую колонку с названием daily, содержащую сумму всех остальных, и сразу же построим по ней гистограмму:

```{r}
data.df["daily"] <- rowSums(data.df[4:27])
hist(data.df$daily)
```

Можно сделать вывод о том, что в таблице присутствует большое число относительно больших отрицательных чисел.

Чтобы убрать их, снача получим некую маску таблицы, в которой TRUE будет только для тех рядов, где нет отрицательных чисел, а затем применим ее к исходной таблице. Маску получим функцией apply:

```{r}
row.mask <- apply(data.df, 1, function(x) all(x>=0))
fixed.df <- data.df[row.mask,]
hist(fixed.df$daily)
```

Данная гистограмма боллее корректна, поскольку в ней нет отрицательных чисел, а осадки, насколько я понимаю, не могут быть отрицательными.

## Синтаксис и типизирование

Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна:

```{r eval=FALSE}
v <- c("4", "8", "15", "16", "23", "42")
max(v) # опять же, максимальный элемент 8, т.к. элементы строковые (character), а лексикографически "8" > "4" > "1"
sort(v) # поскольку элементы строковые, "8" > "4" > "1" и порядок сортировки - прямой лексикографический, отсортировалось именно так а не иначе
sum(v) # не работает, т.к. элементы строковые, будет работать только с числовыми векторами (numberic)
```

Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочна:

```{r eval=FALSE}
v2 <- c("5",7,12) # Если есть хотя бы один строковый элемент, остальные будут преобразованы в строковые
#v2[2] + 2[3] # 2 - v2[2] это char, а 2[3] - это numeric, поэтому не получается выполнить сложение, а еще по-моему нельзя искать 3 элемент в 2, ведь 2 - не вектор, а numberic

df3 <- data.frame(z1="5",z2=7,z3=12) # В df данные лежат в виде факторов, поэтому R понимает, как их складывать
df3[1,2] + df3[1,3]

l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]]
l4[2] + l4[4] # q: In order to reference a list member directly, we have to use the double square bracket "[[]]". Поэтому будет ошибка
```


## Работа с функциями и операторами

Выведем на экран последовательности:

```{r}
print("Числа от 1 до 10000 с инкрементом 372.")
seq(1,10000,372)
print("Числа от 1 до 10000 длиной 50.")
seq(1,10000,length.out = 50)
```

Разница между each и times в функции rep:

```{r}
print("rep(1:5,times=3) просто повторяет исходный вектор times раз")
rep(1:5,times=3)
print("rep(1:5, each=3)  реплицирует каждый элемент исходного вектора each раз")
rep(1:5, each=3)
```

